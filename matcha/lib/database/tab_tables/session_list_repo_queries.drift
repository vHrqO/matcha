import 'tab_tables.drift';


-- order by ui position
getAllSession: SELECT * FROM session ORDER BY position ASC;


addSession: 
-- sets position after the current maximum
-- '-1' for zero-based index
INSERT INTO session (position, name)
VALUES (
  (SELECT IFNULL(MAX(position), -1) + 1 FROM session),
  :name
);


updateSession: UPDATE session SET name = :name WHERE id = :id;


-- need refresh Position after delete
removeSession: DELETE FROM session WHERE id = :id;


refreshPositionSession: 
-- '-1' for zero-based index
WITH Ordered AS (
  SELECT id, ROW_NUMBER() OVER (ORDER BY position) - 1 AS new_pos
  FROM session
)
UPDATE session
  SET position = (
    SELECT new_pos FROM Ordered WHERE Ordered.id = session.id
  );


------reorderSession
reorderSession_getSafeOffset:
SELECT IFNULL(MAX(position), 0) + 1 AS safe_offset
FROM session;

-- push out of range
reorderSession_addOffset(:offset AS INTEGER, :oldIndex AS INTEGER, :newIndex AS INTEGER):
UPDATE session
  SET position = position + :offset
WHERE
  position >= MIN(:oldIndex, :newIndex)
  AND position <= MAX(:oldIndex, :newIndex);

-- moving down (old < new)
reorderSession_shiftDownAndBack(:offset AS INTEGER, :oldIndex AS INTEGER, :newIndex AS INTEGER):
UPDATE session
  SET position = CASE
      WHEN position = :offset + :oldIndex THEN :newIndex
      ELSE (position - 1) - :offset
    END
WHERE
  position >= (:offset + :oldIndex)
  AND position <= (:offset + :newIndex);

-- moving up (old > new)
reorderSession_shiftUpAndBack(:offset AS INTEGER, :oldIndex AS INTEGER, :newIndex AS INTEGER):
UPDATE session
  SET position = CASE
      WHEN position = :offset + :oldIndex THEN :newIndex
      ELSE (position + 1) - :offset
    END
WHERE
  position >= (:offset + :newIndex)
  AND position <= (:offset + :oldIndex);

------





